[
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"simSoc.AXI_ram",
    "name":"AXIRAM.v",
    "text":"\n\nmodule Endian\n(\n    input  wire [63:0] in,\n    output wire [63:0] out\n);\n    assign out[63:56] = in[ 7: 0];\n    assign out[55:48] = in[15: 8];\n    assign out[47:40] = in[23:16];\n    assign out[39:32] = in[31:24];\n    assign out[31:24] = in[39:32];\n    assign out[23:16] = in[47:40];\n    assign out[15: 8] = in[55:48];\n    assign out[7 : 0] = in[63:56];\nendmodule\n// 大尾 改成小尾段\n\n\n    module AXI_ram #\n(\n    // Width of data bus in bits\n    parameter DATA_WIDTH = 64,\n    // Width of address bus in bits\n    parameter ADDR_WIDTH = 20,\n    // Width of wstrb (width of data bus in words)\n    parameter STRB_WIDTH = (DATA_WIDTH/8),\n    // Width of ID signal\n    parameter ID_WIDTH = 4,\n    // Extra pipeline register on output\n    parameter PIPELINE_OUTPUT = 0\n)\n(\n    input  wire                   clock,\n    input  wire                   reset,\n\n    input  wire [ID_WIDTH-1:0]    awid,\n    input  wire [ADDR_WIDTH-1:0]  awaddr,\n    input  wire [7:0]             awlen,\n    input  wire [2:0]             awsize,\n    input  wire [1:0]             awburst,\n    input  wire                   awlock,\n    input  wire [3:0]             awcache,\n    input  wire [2:0]             awprot,\n    input  wire                   awvalid,\n    output wire                   awready,\n\n    input  wire [ID_WIDTH-1:0]    wid,\n    input  wire [DATA_WIDTH-1:0]  wdata,\n    input  wire [STRB_WIDTH-1:0]  wstrb,\n    input  wire                   wlast,\n    input  wire                   wvalid,\n    output wire                   wready,\n\n    output wire [ID_WIDTH-1:0]    bid,\n    output wire [1:0]             bresp,\n    output wire                   bvalid,\n    input  wire                   bready,\n\n    input  wire [ID_WIDTH-1:0]    arid,\n    input  wire [ADDR_WIDTH-1:0]  araddr,\n    input  wire [7:0]             arlen,\n    input  wire [2:0]             arsize,\n    input  wire [1:0]             arburst,\n    input  wire                   arlock,\n    input  wire [3:0]             arcache,\n    input  wire [2:0]             arprot,\n    input  wire                   arvalid,\n    output wire                   arready,\n\n    output wire [ID_WIDTH-1:0]    rid,\n    output wire [DATA_WIDTH-1:0]  rdata,\n    output wire [1:0]             rresp,\n    output wire                   rlast,\n    output wire                   rvalid,\n    input  wire                   rready\n);\n\nparameter VALID_ADDR_WIDTH = ADDR_WIDTH - 3;\nparameter WORD_WIDTH = STRB_WIDTH;\nparameter WORD_SIZE = DATA_WIDTH/WORD_WIDTH;\n\n// bus width assertions\ninitial begin\nend\n\nlocalparam [0:0]\n    READ_STATE_IDLE = 1'd0,\n    READ_STATE_BURST = 1'd1;\n\nreg [0:0] read_state_reg = READ_STATE_IDLE, read_state_next;\n\nlocalparam [1:0]\n    WRITE_STATE_IDLE = 2'd0,\n    WRITE_STATE_BURST = 2'd1,\n    WRITE_STATE_RESP = 2'd2;\n\nreg [1:0] write_state_reg = WRITE_STATE_IDLE, write_state_next;\n\nreg mem_wr_en;\nreg mem_rd_en;\n\nreg [ID_WIDTH-1:0] read_id_reg = {ID_WIDTH{1'b0}}, read_id_next;\nreg [ADDR_WIDTH-1:0] read_addr_reg = {ADDR_WIDTH{1'b0}}, read_addr_next;\nreg [7:0] read_count_reg = 8'd0, read_count_next;\nreg [2:0] read_size_reg = 3'd0, read_size_next;\nreg [1:0] read_burst_reg = 2'd0, read_burst_next;\nreg [ID_WIDTH-1:0] write_id_reg = {ID_WIDTH{1'b0}}, write_id_next;\nreg [ADDR_WIDTH-1:0] write_addr_reg = {ADDR_WIDTH{1'b0}}, write_addr_next;\nreg [7:0] write_count_reg = 8'd0, write_count_next;\nreg [2:0] write_size_reg = 3'd0, write_size_next;\nreg [1:0] write_burst_reg = 2'd0, write_burst_next;\n\nreg awready_reg = 1'b0, awready_next;\nreg wready_reg = 1'b0, wready_next;\nreg [ID_WIDTH-1:0] bid_reg = {ID_WIDTH{1'b0}}, bid_next;\nreg bvalid_reg = 1'b0, bvalid_next;\nreg arready_reg = 1'b0, arready_next;\nreg [ID_WIDTH-1:0] rid_reg = {ID_WIDTH{1'b0}}, rid_next;\nreg [DATA_WIDTH-1:0] rdata_reg = {DATA_WIDTH{1'b0}}, rdata_next;\nreg rlast_reg = 1'b0, rlast_next;\nreg rvalid_reg = 1'b0, rvalid_next;\nreg [ID_WIDTH-1:0] rid_pipe_reg = {ID_WIDTH{1'b0}};\nreg [DATA_WIDTH-1:0] rdata_pipe_reg = {DATA_WIDTH{1'b0}};\nreg rlast_pipe_reg = 1'b0;\nreg rvalid_pipe_reg = 1'b0;\n\n// (* RAM_STYLE=\"BLOCK\" *)\nreg [DATA_WIDTH-1:0] mem[(2**VALID_ADDR_WIDTH)-1:0];\n\n// wire [VALID_ADDR_WIDTH-1:0] awaddr_valid = (awaddr >> (ADDR_WIDTH - VALID_ADDR_WIDTH))[VALID_ADDR_WIDTH-1:0];\nwire [VALID_ADDR_WIDTH-1:0] awaddr_valid = awaddr >> (ADDR_WIDTH - VALID_ADDR_WIDTH);\nwire [VALID_ADDR_WIDTH-1:0] araddr_valid = araddr >> (ADDR_WIDTH - VALID_ADDR_WIDTH);\nwire [VALID_ADDR_WIDTH-1:0] read_addr_valid  = read_addr_reg  >> (ADDR_WIDTH - VALID_ADDR_WIDTH);\nwire [VALID_ADDR_WIDTH-1:0] write_addr_valid = write_addr_reg >> (ADDR_WIDTH - VALID_ADDR_WIDTH);\n\nassign awready = awready_reg;\nassign wready = wready_reg;\nassign bid = bid_reg;\nassign bresp = 2'b00;\nassign bvalid = bvalid_reg;\nassign arready = arready_reg;\nassign rid = PIPELINE_OUTPUT ? rid_pipe_reg : rid_reg;\n\nwire [63:0] rdata_big;\nassign rdata_big = PIPELINE_OUTPUT ? rdata_pipe_reg : rdata_reg;\nEndian ed1(\n    .in(rdata_big),\n    .out(rdata)\n);\n\n\n\nassign rresp = 2'b00;\nassign rlast = PIPELINE_OUTPUT ? rlast_pipe_reg : rlast_reg;\nassign rvalid = PIPELINE_OUTPUT ? rvalid_pipe_reg : rvalid_reg;\n\ninteger i, j, mem_file;\n\ninitial begin\n    // two nested loops for smaller number of iterations per loop\n    // workaround for synthesizer complaints about large loop counts\n    for (i = 0; i < 2**VALID_ADDR_WIDTH; i = i + 2**(VALID_ADDR_WIDTH/2)) begin\n        for (j = i; j < i + 2**(VALID_ADDR_WIDTH/2); j = j + 1) begin\n            mem[j] = 0;\n        end\n    end\n//     mem[0x80000000] = 32'h863; mem[1] = 32'h06400093; mem[2] = 32'h00000013; mem[3] = 32'h00000013; mem[4] = 32'h00102023; mem[5] = 32'h00002103;\n    // mem[6] = 32'h00f00093; mem[7] = 32'h34101073; mem[8] = 32'h34109073; mem[9] = 32'h34186073; mem[10] = 32'h341020f3;\n//    mem_file = $fopen(\"/Users/cgk/ownCloud/课程/一生一芯/ict/test.bin\", \"r\");\n    mem_file = $fopen(\"/home/yanyue/nutshell_v2/kisscpu/nexus-am/tests/cputest/build/dummy-riscv64-nutshell.bin\", \"r\");\n    $fread(mem, mem_file);\nend\n\nalways @* begin\n    write_state_next = WRITE_STATE_IDLE;\n\n    mem_wr_en = 1'b0;\n\n    write_id_next = write_id_reg;\n    write_addr_next = write_addr_reg;\n    write_count_next = write_count_reg;\n    write_size_next = write_size_reg;\n    write_burst_next = write_burst_reg;\n\n    awready_next = 1'b0;\n    wready_next = 1'b0;\n    bid_next = bid_reg;\n    bvalid_next = bvalid_reg && !bready;\n\n    case (write_state_reg)\n        WRITE_STATE_IDLE: begin\n            awready_next = 1'b1;\n\n            if (awready && awvalid) begin\n                write_id_next = awid;\n                write_addr_next = awaddr;\n                write_count_next = awlen;\n                write_size_next = awsize < 2 ? awsize : 2;\n                write_burst_next = awburst;\n\n                awready_next = 1'b0;\n                wready_next = 1'b1;\n                write_state_next = WRITE_STATE_BURST;\n            end else begin\n                write_state_next = WRITE_STATE_IDLE;\n            end\n        end\n        WRITE_STATE_BURST: begin\n            wready_next = 1'b1;\n\n            if (wready && wvalid) begin\n                mem_wr_en = 1'b1;\n                if (write_burst_reg != 2'b00) begin\n                    write_addr_next = write_addr_reg + (1 << write_size_reg);\n                end\n                write_count_next = write_count_reg - 1;\n                if (write_count_reg > 0) begin\n                    write_state_next = WRITE_STATE_BURST;\n                end else begin\n                    wready_next = 1'b0;\n                    if (bready || !bvalid) begin\n                        bid_next = write_id_reg;\n                        bvalid_next = 1'b1;\n                        awready_next = 1'b1;\n                        write_state_next = WRITE_STATE_IDLE;\n                    end else begin\n                        write_state_next = WRITE_STATE_RESP;\n                    end\n                end\n            end else begin\n                write_state_next = WRITE_STATE_BURST;\n            end\n        end\n        WRITE_STATE_RESP: begin\n            if (bready || !bvalid) begin\n                bid_next = write_id_reg;\n                bvalid_next = 1'b1;\n                awready_next = 1'b1;\n                write_state_next = WRITE_STATE_IDLE;\n            end else begin\n                write_state_next = WRITE_STATE_RESP;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clock) begin\n    if (reset) begin\n        write_state_reg <= WRITE_STATE_IDLE;\n        awready_reg <= 1'b0;\n        wready_reg <= 1'b0;\n        bvalid_reg <= 1'b0;\n    end else begin\n        write_state_reg <= write_state_next;\n        awready_reg <= awready_next;\n        wready_reg <= wready_next;\n        bvalid_reg <= bvalid_next;\n    end\n\n    write_id_reg <= write_id_next;\n    write_addr_reg <= write_addr_next;\n    write_count_reg <= write_count_next;\n    write_size_reg <= write_size_next;\n    write_burst_reg <= write_burst_next;\n\n    bid_reg <= bid_next;\n\n    for (i = 0; i < WORD_WIDTH; i = i + 1) begin\n        if (mem_wr_en & wstrb[i]) begin\n            mem[write_addr_valid][WORD_SIZE*i +: WORD_SIZE] <= wdata[WORD_SIZE*i +: WORD_SIZE];\n        end\n    end\nend\n\nalways @* begin\n    read_state_next = READ_STATE_IDLE;\n\n    mem_rd_en = 1'b0;\n\n    rid_next = rid_reg;\n    rlast_next = rlast_reg;\n    rvalid_next = rvalid_reg && !(rready || (PIPELINE_OUTPUT && !rvalid_pipe_reg));\n\n    read_id_next = read_id_reg;\n    read_addr_next = read_addr_reg;\n    read_count_next = read_count_reg;\n    read_size_next = read_size_reg;\n    read_burst_next = read_burst_reg;\n\n    arready_next = 1'b0;\n\n    case (read_state_reg)\n        READ_STATE_IDLE: begin\n            arready_next = 1'b1;\n\n            if (arready && arvalid) begin\n                read_id_next = arid;\n                read_addr_next = araddr;\n                read_count_next = arlen;\n                read_size_next = arsize < 2 ? arsize : 2;\n                read_burst_next = arburst;\n\n                arready_next = 1'b0;\n                read_state_next = READ_STATE_BURST;\n            end else begin\n                read_state_next = READ_STATE_IDLE;\n            end\n        end\n        READ_STATE_BURST: begin\n            if (rready || (PIPELINE_OUTPUT && !rvalid_pipe_reg) || !rvalid_reg) begin\n                mem_rd_en = 1'b1;\n                rvalid_next = 1'b1;\n                rid_next = read_id_reg;\n                rlast_next = read_count_reg == 0;\n                if (read_burst_reg != 2'b00) begin\n                    read_addr_next = read_addr_reg + (1 << read_size_reg);\n                end\n                read_count_next = read_count_reg - 1;\n                if (read_count_reg > 0) begin\n                    read_state_next = READ_STATE_BURST;\n                end else begin\n                    arready_next = 1'b1;\n                    read_state_next = READ_STATE_IDLE;\n                end\n            end else begin\n                read_state_next = READ_STATE_BURST;\n            end\n        end\n        default: ;\n    endcase\nend\n\nalways @(posedge clock) begin\n    if (reset) begin\n        read_state_reg <= READ_STATE_IDLE;\n        arready_reg <= 1'b0;\n        rvalid_reg <= 1'b0;\n        rvalid_pipe_reg <= 1'b0;\n    end else begin\n        read_state_reg <= read_state_next;\n        arready_reg <= arready_next;\n        rvalid_reg <= rvalid_next;\n\n        if (!rvalid_pipe_reg || rready) begin\n            rvalid_pipe_reg <= rvalid_reg;\n        end\n    end\n\n    read_id_reg <= read_id_next;\n    read_addr_reg <= read_addr_next;\n    read_count_reg <= read_count_next;\n    read_size_reg <= read_size_next;\n    read_burst_reg <= read_burst_next;\n\n    rid_reg <= rid_next;\n    rlast_reg <= rlast_next;\n\n    if (mem_rd_en) begin\n        rdata_reg <= mem[read_addr_valid];\n    end\n\n    if (!rvalid_pipe_reg || rready) begin\n        rid_pipe_reg <= rid_reg;\n        rdata_pipe_reg <= rdata_reg;\n        rlast_pipe_reg <= rlast_reg;\n    end\nend\n\nendmodule\n    "
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"simSoc.AXI_Bridge",
    "name":"AXI_Bridge.v",
    "text":"\n           module AXI_Bridge\n           (\n               input         clock,\n               input         reset,\n           \n               //inst sram-like\n               input         inst_req     ,\n               input         inst_wr      ,\n               input  [2 :0] inst_size    ,\n               input  [63:0] inst_addr    ,\n               input  [63:0] inst_wdata   ,\n               output [63:0] inst_rdata   ,\n               output        inst_addr_ok ,\n               output        inst_data_ok ,\n           \n               //data sram-like\n               input         data_req     ,\n               input         data_wr      ,\n               input  [2 :0] data_size    ,\n               input  [63:0] data_addr    ,\n               input  [63:0] data_wdata   ,\n               output [63:0] data_rdata   ,\n               output        data_addr_ok ,\n               output        data_data_ok ,\n           \n               //axi\n               //ar\n               output [3 :0] arid         ,\n               output [63:0] araddr       ,\n               output [7 :0] arlen        ,\n               output [2 :0] arsize       ,\n               output [1 :0] arburst      ,\n               output        arlock        ,\n               output [3 :0] arcache      ,\n               output [2 :0] arprot       ,\n               output        arvalid      ,\n               input         arready      ,\n               //r\n               input  [3 :0] rid          ,\n               input  [63:0] rdata        ,\n               input  [1 :0] rresp        ,\n               input         rlast        ,\n               input         rvalid       ,\n               output        rready       ,\n               //aw\n               output [3 :0] awid         ,\n               output [63:0] awaddr       ,\n               output [7 :0] awlen        ,\n               output [2 :0] awsize       ,\n               output [1 :0] awburst      ,\n               output        awlock       ,\n               output [3 :0] awcache      ,\n               output [2 :0] awprot       ,\n               output        awvalid      ,\n               input         awready      ,\n               //w\n               output [3 :0] wid          ,\n               output [63:0] wdata        ,\n               output [7 :0] wstrb        ,\n               output        wlast        ,\n               output        wvalid       ,\n               input         wready       ,\n               //b\n               input  [3 :0] bid          ,\n               input  [1 :0] bresp        ,\n               input         bvalid       ,\n               output        bready\n           );\nwire resetn = !reset;\n//addr\nreg do_req;\nreg do_req_or; //req is inst or data;1:data,0:inst\nreg        do_wr_r;\nreg [2 :0] do_size_r;\nreg [63:0] do_addr_r;\nreg [63:0] do_wdata_r;\nwire data_back;\n\nassign inst_addr_ok = !do_req&&!data_req;\nassign data_addr_ok = !do_req;\nalways @(posedge clock)\nbegin\n    do_req     <= !resetn                       ? 1'b0 :\n                  (inst_req||data_req)&&!do_req ? 1'b1 :\n                  data_back                     ? 1'b0 : do_req;\n    do_req_or  <= !resetn ? 1'b0 :\n                  !do_req ? data_req : do_req_or;\n\n    do_wr_r    <= data_req&&data_addr_ok ? data_wr :\n                  inst_req&&inst_addr_ok ? inst_wr : do_wr_r;\n    do_size_r  <= data_req&&data_addr_ok ? data_size :\n                  inst_req&&inst_addr_ok ? inst_size : do_size_r;\n    do_addr_r  <= data_req&&data_addr_ok ? data_addr :\n                  inst_req&&inst_addr_ok ? inst_addr : do_addr_r;\n    do_wdata_r <= data_req&&data_addr_ok ? data_wdata :\n                  inst_req&&inst_addr_ok ? inst_wdata :do_wdata_r;\nend\n\n//inst sram-like\nassign inst_data_ok = do_req&&!do_req_or&&data_back;\nassign data_data_ok = do_req&& do_req_or&&data_back;\nassign inst_rdata   = rdata;\nassign data_rdata   = rdata;\n\n//---axi\nreg addr_rcv;\nreg wdata_rcv;\n\nassign data_back = addr_rcv && (rvalid&&rready||bvalid&&bready);\nalways @(posedge clock)\nbegin\n    addr_rcv  <= !resetn          ? 1'b0 :\n                 arvalid&&arready ? 1'b1 :\n                 awvalid&&awready ? 1'b1 :\n                 data_back        ? 1'b0 : addr_rcv;\n    wdata_rcv <= !resetn        ? 1'b0 :\n                 wvalid&&wready ? 1'b1 :\n                 data_back      ? 1'b0 : wdata_rcv;\nend\n//ar\nassign arid    = 4'd0;\nassign araddr  = do_addr_r;\nassign arlen   = 8'd0;\nassign arsize  = do_size_r;\nassign arburst = 2'd0;\nassign arlock  = 1'd0;\nassign arcache = 4'd0;\nassign arprot  = 3'd0;\nassign arvalid = do_req&&!do_wr_r&&!addr_rcv;\n//r\nassign rready  = 1'b1;\n\n//aw\nassign awid    = 4'd0;\nassign awaddr  = do_addr_r;\nassign awlen   = 8'd0;\nassign awsize  = do_size_r;\nassign awburst = 2'd0;\nassign awlock  = 1'd0;\nassign awcache = 4'd0;\nassign awprot  = 3'd0;\nassign awvalid = do_req&&do_wr_r&&!addr_rcv;\n//w\nassign wid    = 4'd0;\nassign wdata  = do_wdata_r;\nassign wstrb  = do_size_r==3'd0 ? 8'b00000001<<do_addr_r[2:0] :\n                do_size_r==3'd1 ? 8'b00000011<<do_addr_r[2:0] :\n                do_size_r==3'd2 ? 8'b00001111<<do_addr_r[2:0] : 8'b11111111;\nassign wlast  = 1'd1;\nassign wvalid = do_req&&do_wr_r&&!wdata_rcv;\n//b\nassign bready  = 1'b1;\n\nendmodule\n\n\n           \n    "
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|dpath>ws_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|dpath>wb_reg_pc"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_3"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_4"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_5"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_6"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_7"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_8"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_9"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_10"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_11"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_12"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_13"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_14"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_15"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_16"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_17"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_18"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_19"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_20"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_21"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_22"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_23"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_24"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_25"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_26"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_27"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_28"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_29"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_30"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|regfile>_T_41_31"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~simSoc|cpath>nemu_halt"
  },
  {
    "class":"firrtl.options.TargetDirAnnotation",
    "directory":"."
  },
  {
    "class":"firrtl.options.OutputAnnotationFileAnnotation",
    "file":"simSoc"
  },
  {
    "class":"firrtl.EmitCircuitAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"."
  }
]