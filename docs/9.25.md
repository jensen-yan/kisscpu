1. 今天花了很多时间尝试使用Clion来对C++文件进行调试, 但是失败了, 不过还是更加熟悉clion这个工具了吧, 只是现在对于Makefile的支持还不是特别好, 导致一直无法debug.
2. 还是回到主干部分, 继续编写五级流水线吧.
3. 看nutshell的debug代码的Makefile, 还是很奇怪啊, 似乎用了am, 但是ARCH不支持nutshell的框架啊. 然后也用了soder的test, 但是soder的要使用riscv-elf 的编译器, 安装一次似乎要6个G, 还能用别的方法吗?
   1. 使用soder的, 安装elf的, 直接编译, 但是如何装入内存中?
   2. 使用nutshell的, 再阅读下源代码, 使用am框架



#### 构建microbench

1. 在kisscpu下clone <https://github.com/OSCPU/nexus-am>  (这个和ics课程的am不同, 专用于nutshell的)

2. 修改am/arch/isa/riscv64.mk  参考<https://blog.csdn.net/weiqi7777/article/details/88045720#t5> 可以使用不同版本的编译器

   ```makefile
   # CROSS_COMPILE := riscv64-linux-gnu-
   CROSS_COMPILE := riscv64-unknown-linux-gnu-
   # 因为我电脑上只有这个的编译器, 可以改
   ```

3. 执行

   1. ```
      cd nexus-am/apps/microbench
      make ARCH=riscv64-nutshell mainargs=test run AM_HOME=/home/yanyue/nutshell_v2/kisscpu/nexus-am
      # 只改了AM_HOME, 还可以改别的
      ```

      会在apps/microbench/build中生成bin文件, txt文件等



bug:

每次读出来两条指令了, 并且拼在了一起!

为何生成的是32位的?

pc 到底应该每次+4还是+8???   

服了, 原来看官方手册, 64位汇编还是pc+4, 指令还是32位的.......

那么我仍然可以按照32位处理器来设计cpu, 只需要非常微小的改动就可以了

```
	80000000:	00000413          	li	s0,0
    80000004:	00009117          	auipc	sp,0x9
    // sp = 0x80009004
    80000008:	ffc10113          	addi	sp,sp,-4 
    // sp = 0x80009000 <_end>
    8000000c:	034000ef          	jal	ra,80000040 <_trm_init>
    // ra = 0x80000010, pc = 0x80000040
    80000010:	00000513          	li	a0,0  // 不该走
    80000014:	00008067          	ret	// jalr x0, x1, 0
    		// pc = 0x80000010
    
    <_trm_init>
    80000040:	ff010113          	addi	sp,sp,-16
    // sp = 0x80008ff0
    80000044:	00113423          	sd	ra,8(sp)
    // ra -> 某个位置, 不管
    80000048:	014000ef          	jal	ra,8000005c <__am_init_uartlite>
    // ra = 0x8000004c, pc =  0x8000005c
    8000004c:	00001517          	auipc	a0,0x1
    80000050:	b2150513          	addi	a0,a0,-1247 # 80000b6d 
    80000054:	fbdff0ef          	jal	ra,80000010 <_etext>
    80000058:	fc5ff0ef          	jal	ra,8000001c <_halt>
    
    000000008000005c <__am_init_uartlite>:
    8000005c:	406007b7          	lui	a5,0x40600
    80000060:	00300713          	li	a4,3
    80000064:	00e78623          	sb	a4,12(a5) # 4060000c <_pmem_start-0x3f9ffff4>
    80000068:	00008067          	ret
```



```
auipc:  rd, immediate 
			x[rd] = pc + sext(immediate[31:12] << 12)
把符号位扩展的 20 位（左移 12 位）立即数加到 pc 上，结果写入 x[rd]。


jal rd, offset 
			x[rd] = pc+4; pc += sext(offset)
把下一条指令的地址(pc+4)，然后把 pc 设置为当前值加上符号位扩展的 offset。rd 默认为 x1。 ujtype
offset[20|10:1|11|19:12] rd 1101111

jalr rd, offset(rs1) 
		t =pc+4; pc=(x[rs1]+sext(offset))&~1; x[rd]=t
把 pc 设置为 x[rs1] + sign-extend(offset)，把计算出的地址的最低有效位设为 0，并将原 pc+4的值写入 f[rd]。 rd 默认为 x1。
```




bug: 在dec的jal指令 pc+=offset, 但是soder在exe加的pc, 应该是dec的pc, 少了4, 怎么办? 没有延迟槽技术?

