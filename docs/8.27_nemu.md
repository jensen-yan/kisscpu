8.27



### 学习南京大学课程

1. 统计代码行数

   ```c
   find . | grep '\.c$\|\.h$' | xargs wc -l
   ```

   1. find 搜索目录文件中 . (当前文件所在目录), 列出所有文件

   2. grep 正则匹配对应文件,  -v 选中不匹配的

   3. xargs 把标准输入转换为参数, 传送给第一个参数指定的程序, 等价于如下`wc -l a.c b.c `   (markdown 用反引号` 来作为代码)

   4. 如下

      ```
      ./myprog < data > /dev/null
      ```

      `/dev/null`是一个特殊的文件, 任何试图输出到它的信息都会被丢弃. 总之, 上面的命令将`myprog`的输出过滤掉, 保留了`time`的计时结果, 方便又整洁.

   5. Makefile 格式如下

      ```
      hello:hello.c
          gcc hello.c -o hello    # 注意开头的tab, 而不是空格
      
      .PHONY: clean  # 防止已经有clean文件, 说明clean是伪目标
      
      clean:
          rm hello    # 注意开头的tab, 而不是空格
      ```

   6. 对于 #!/bin/bash 开头的脚本文件 用bash ... 来执行!

   7.  ^E 表示 ctrl + E;  CR 表示回车键;  \pattern 来搜索, 用n下一个, N上一个

   8. 在新的分支中提交代码, 不要用git commit, 用 `git checkout -B 分支名`

   9. 注意我使用的是zsh, 不是bash, 要用`source ~./zshrc ` 

### NEMU

1. 在NEMU中，每一个硬件部件都由一个程序相关的数据对象来模拟，例如变量，排列，结构体等；而对这些部件的操作则通过对相应数据对象的操作来模拟。例如NEMU中使用复制来模拟内存，那么对这个副本进行读取则相当于对内存进行读取。
2. nemu 由 monitor, cpu, mem, 设备构成
3. NEMU是一个用来执行客户程序的程序，但客户程序一开始并不存在于客户计算机中。我们需要将客户程序读入到客户计算机中，这件事是monitor来负责的, 需要init_monitor()
4. 约定。具体地，我们让monitor直接把一个累积的客户程序读入到一个固定的内存位置`IMAGE_START`（也就是`0x100000`

```c
const uint32_t isa_default_img [] = {
  0x800002b7,  // lui t0,0x8000  t0 = 0x8000_0000
  0x0002a023,  // sw  zero,0(t0) 0x8000_0000位置为0
  0x0002a503,  // lw  a0,0(t0)   a0 = 0
  0x0000006b,  // nemu_trap
};
```

  PC 取指从0x8100_0000开始

6.  如果运行NEMU时未指定客户程序，那么monitor将读入一个内置的客户程序,放在`nemu/src/isa/$ISA/init.c`中
7. 对于某些ISA来说，物理内存并不是从0开始编址的，例如mips32和riscv32的物理地址均从`0x80000000`开始。
8. 将来CPU访问内存时，我们重定向CPU将需要访问的内存地址映射到`pmem`中的相应替换位置。例如如果mips32的CPU打算访问内存地址`0x80001234`，我们最终就会将其访问`pmem[0x1234]`。这种机制有一个专门的名字，叫地址映射，在后续的PA中我们将会再遇到它。
9. `cpu.pc`初始化寄存器的一个重要工作是将的初始值设置为`PC_START`，通过 `PC_START`地址映射之后会得到刚才我们约定的内存位置`0x100000`，这样就可以让CPU从我们约定的内存位置开始执行客户程序了


