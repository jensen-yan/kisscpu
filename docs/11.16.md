

```
div:

right pc = [0x        8000007c], wrong pc = [0x        80000088]  cyc = 418

80000070:	00b00693          	li	a3,11
    80000074:	00062703          	lw	a4,0(a2)
    80000078:	00100793          	li	a5,1
    8000007c:	02f7073b          	mulw	a4,a4,a5
    80000080:	0017879b          	addiw	a5,a5,1
    80000084:	fed79ce3          	bne	a5,a3,8000007c <main+0x54>
    // a3=b, a5=2, 不等, 回到7c, 不应该到88
    80000088:	00e62023          	sw	a4,0(a2)
    8000008c:	00460613          	addi	a2,a2,4
    
    cyc=344, bne刚进入if, 但是直接取指令80000088的, 分支预测错误
    cyc = 347,80000084 这条指令错误, 应该是fed79ce3, 不是0017879b, 但恰好用了错误的, 应该等bne进入dec才去译码, 但这时候bne阻塞在if, dec的addiw译码, if_pc_next错误, 取出了错误的指令, dummy怎么过的?
    原来跳转指令获得data_ok后, 进入dec,这一拍才发请求,这时pc_next刚好变化, pre_if 就用变化后的地址去取指令, 取出的就是跳转后的指令, 还真是一个巧合啊!
    cyc=407, bne才进入dec, 这时候应该刷新一下if的指令(把pc, inst都变成nop, 或者把if_valid变成0, 或者在它进入dec时候valid变成0),但这时候由于if取出的是80000088指令,等了好几拍之后, 它的data_ok后的下一拍, 直接取8000008c指令了, 真正的8000007c指令地址被丢失了, 怎么办呢?
    尝试失败: 让inst_fetching直到ds_allowin流水才变成0, 阻碍延迟槽指令的取指, 但是这样形成了很奇怪的现象, 还是别把inst_fecthing的语义弄得太复杂, 简单就好
```

